# 登录模块后端设计文档

## 1. 整体设计原则

### 架构基础

采用Spring Boot框架构建RESTful API后端，确保轻量级、易扩展。模块独立成一个Controller（AuthController）和Service（CaptchaService），遵循MVC模式。Controller负责HTTP接口处理，Service处理核心业务逻辑（如验证码生成、验证逻辑）。使用JPA进行数据持久化，Lombok简化实体类和日志。

### 存储策略

**用户数据存储**：采用MySQL数据库存储用户信息，通过JPA/Hibernate进行ORM映射。用户实体表（auth_user）包含以下字段：
- `id`（主键，Long类型）
- `password`（密码，String类型，明文存储，后续可升级为BCrypt加密）
- `last_login_time`（最后登录时间，LocalDateTime类型）
- `last_login_ip`（最后登录IP，String类型，支持IPv6）

**验证码存储**：采用内存存储（ConcurrentHashMap），不引入Redis等外部缓存。每个验证码记录包含：
- `code`：验证码字符串（4位，排除易混淆字符）
- `expireAt`：过期时间（Instant类型，默认5分钟）
- `verifyCodeId`：UUID作为唯一标识，用于关联验证码和图片

**会话存储**：采用HttpSession（基于Servlet容器，默认使用内存存储）。会话中存储`currentUserId`，用于标识当前登录用户。会话超时时间配置为2小时（可通过`application.yml`调整）。

**优点**：
- MySQL持久化用户数据，支持事务和查询
- 内存验证码响应快，无需外部依赖
- Session机制成熟，Spring Boot自动管理

**缺点**：
- 验证码重启后丢失（当前场景可接受，用户重新获取即可）
- Session在集群环境下需配置共享（如Redis Session Store），当前单机部署可接受
- 密码明文存储存在安全风险（后续需升级为BCrypt加密）

### 与前端交互

**请求格式**：所有接口采用JSON格式，Content-Type为`application/json`。登录请求包含用户ID、密码、验证码ID和验证码值，以及可选的客户端信息（操作系统、浏览器、IP）。

**响应格式**：统一返回`ApiResponse<T>`格式：
- 成功：`{"code": 200, "msg": "操作成功", "data": {...}}`
- 失败：`{"code": 4xx/5xx, "msg": "错误信息", "data": null}`

**验证码图片**：采用Base64编码的PNG图片，格式为`data:image/png;base64,{base64字符串}`，前端可直接通过`<img src={base64String}>`显示。

**会话管理**：前端无需手动管理token，浏览器自动携带JSESSIONID cookie。登录成功后，后续请求自动关联会话；退出登录时，前端调用logout接口，后端销毁会话。

### 错误处理与安全性

**统一返回格式**：成功用200 + JSON msg，失败用4xx/5xx + 错误msg（e.g., `{"code": 400, "msg": "验证码错误或已过期", "data": null}`）。

**认证与授权**：
- 当前实现为管理员专用登录（通过`app.security.admin-only-id`配置，默认只允许ID为1的用户登录）
- 未登录用户访问`/api/auth/currentUser`时返回401 Unauthorized
- 会话超时后自动失效，需重新登录

**异常处理**：
- 使用全局异常处理器（GlobalExceptionHandler）统一捕获BusinessException和UnauthorizedException
- 验证码生成失败用try-catch包装，抛出RuntimeException并记录日志
- 数据库查询异常由JPA自动处理，返回相应错误码

**安全考虑**：
- 验证码验证后立即删除，防止重复使用
- 验证码过期自动清理（validate时触发cleanup）
- 密码验证失败不提示具体错误（账号不存在或密码错误统一返回"账号或密码错误"）
- 登录成功记录IP和时间，便于审计

### 性能考虑

**验证码生成**：使用Java AWT生成图片，Base64编码，单次请求耗时<50ms。验证码存储在ConcurrentHashMap，读取O(1)复杂度。

**用户查询**：使用JPA的`findById`方法，基于主键查询，MySQL索引优化，响应时间<10ms。

**会话管理**：Servlet容器内存存储，读写快速。会话超时自动清理，无需手动维护。

**并发处理**：ConcurrentHashMap支持高并发读写，验证码生成和验证线程安全。Session由容器管理，支持多用户并发登录。

### 测试友好

Service方法纯函数化（如CaptchaService的generateCaptcha和validate），便于单元测试（Mock时间、Mock随机数）。Controller方法依赖注入，可Mock Service层进行集成测试。数据库使用H2内存数据库进行测试，无需真实MySQL环境。

## 2. 核心功能设计

### 功能1: 获取验证码图片（GET /api/auth/getVerifyCodeImg）

**触发场景**：前端登录页面加载时调用，或用户点击"刷新验证码"按钮时调用。

**业务逻辑**：
1. Service调用`captchaService.generateCaptcha()`生成验证码：
   - 随机生成4位字符（排除易混淆字符：0、O、1、I、l）
   - 生成UUID作为verifyCodeId
   - 计算过期时间（当前时间 + 5分钟）
   - 将验证码记录存储到ConcurrentHashMap（key=verifyCodeId, value=CaptchaRecord）
2. 生成验证码图片：
   - 创建120x40像素的BufferedImage
   - 使用Arial字体绘制验证码文字
   - 转换为PNG格式，编码为Base64字符串
   - 添加data URI前缀：`data:image/png;base64,{base64}`
3. 返回结果：
   - verifyCodeId：用于后续验证时关联
   - verifyCodeImgBase64：Base64编码的图片数据
   - expireTime：过期时间（ZonedDateTime格式，包含时区信息）

**与前端交互**：
- 返回JSON：`{"code": 200, "msg": "验证码图片获取成功", "data": {"verifyCodeId": "uuid", "verifyCodeImgBase64": "data:image/png;base64,...", "expireTime": "2025-11-03T18:11:18+08:00[Asia/Shanghai]"}}`
- 前端解析后，将`verifyCodeImgBase64`直接赋值给`<img src>`显示
- 前端保存`verifyCodeId`，用于登录时提交

**边界处理**：
- 图片生成失败：捕获异常，返回500错误，记录日志
- 验证码存储满（理论上不会，ConcurrentHashMap无上限，但可添加LRU清理策略）

**Python端交互**：无，纯Java本地生成。

### 功能2: 用户登录（POST /api/auth/login）

**触发场景**：用户填写账号、密码、验证码后，点击"登录"按钮提交。

**业务逻辑**：
1. **请求验证**：
   - 使用`@Valid`注解验证请求体（userid、password、verifyCode、verifyCodeId不能为空）
   - 如果验证失败，返回400错误

2. **验证码校验**：
   - 调用`captchaService.validate(verifyCodeId, verifyCode)`验证验证码
   - 验证码不存在或已过期：返回400 `{"code": 400, "msg": "验证码错误或已过期"}`
   - 验证码不匹配（忽略大小写）：返回400错误
   - 验证成功后，立即删除验证码记录（防止重复使用）

3. **用户认证**：
   - 从数据库查询用户：`userRepository.findById(userid)`
   - 用户不存在：返回400 `{"code": 400, "msg": "账号或密码错误"}`（不暴露具体原因）
   - 密码验证：比较`user.getPassword().equals(req.getPassword())`（当前明文比较，后续需升级为BCrypt）
   - 密码错误：返回400 `{"code": 400, "msg": "账号或密码错误"}`

4. **权限检查**：
   - 检查用户ID是否等于配置的`admin-only-id`（默认1）
   - 如果不是管理员：返回400 `{"code": 400, "msg": "无权登录"}`

5. **更新用户信息**：
   - 提取登录IP：优先使用请求体中的`clientInfo.loginIp`，否则使用`HttpServletRequest.getRemoteAddr()`
   - 更新用户的`lastLoginTime`和`lastLoginIp`
   - 保存到数据库：`userRepository.save(user)`

6. **创建会话**：
   - 获取或创建HttpSession：`httpReq.getSession(true)`
   - 在会话中存储用户ID：`session.setAttribute("currentUserId", user.getId())`
   - 会话超时时间由`server.servlet.session.timeout`配置（默认2小时）

7. **返回结果**：
   - 返回200 `{"code": 200, "msg": "登录成功", "data": {"user": {"id": 1}}}`

**与前端交互**：
- 请求体格式：
```json
{
  "userid": 1,
  "password": "your_password",
  "verifyCode": "ABCD",
  "verifyCodeId": "uuid",
  "clientInfo": {
    "os": "Windows",
    "browser": "Chrome",
    "loginIp": "127.0.0.1"
  }
}
```
- 登录成功后，前端保存会话（浏览器自动管理JSESSIONID cookie）
- 前端跳转到主页面，后续请求自动携带会话信息

**边界处理**：
- 验证码已使用：验证后立即删除，重复提交会失败
- 并发登录：同一用户多次登录会创建多个会话（当前允许，后续可限制单点登录）
- 数据库连接失败：由JPA异常处理，返回500错误

**Python端交互**：无，纯Java后端处理。

### 功能3: 获取当前用户信息（GET /api/auth/currentUser）

**触发场景**：前端需要获取当前登录用户信息时调用（如页面加载时检查登录状态、显示用户信息）。

**业务逻辑**：
1. **会话验证**：
   - 获取当前会话：`httpReq.getSession(false)`（不创建新会话）
   - 会话不存在或`currentUserId`为空：抛出`UnauthorizedException`，返回401 `{"code": 401, "msg": "未登录或会话已过期", "data": null}`

2. **用户查询**：
   - 从会话获取用户ID：`session.getAttribute("currentUserId")`
   - 从数据库查询用户：`userRepository.findById(userId)`
   - 用户不存在（异常情况）：返回401错误

3. **返回结果**：
   - 返回200 `{"code": 200, "msg": "ok", "data": {"id": 1, "lastLoginTime": "2025-11-03T18:15:30", "lastLoginIp": "127.0.0.1"}}`

**与前端交互**：
- 前端定期调用此接口检查登录状态（如每5分钟轮询一次）
- 如果返回401，前端跳转到登录页面
- 前端使用返回的用户信息显示在页面上（如"欢迎，用户ID: 1"）

**边界处理**：
- 会话过期：自动返回401，前端提示重新登录
- 用户被删除：返回401（异常情况，实际应禁止删除已登录用户）

**Python端交互**：无，纯Java后端处理。

### 功能4: 退出登录（POST /api/auth/logout）

**触发场景**：用户点击"退出登录"按钮时调用。

**业务逻辑**：
1. **会话销毁**：
   - 获取当前会话：`httpReq.getSession(false)`
   - 如果会话存在，调用`session.invalidate()`销毁会话
   - 销毁后，`currentUserId`等会话属性自动清除

2. **返回结果**：
   - 返回200 `{"code": 200, "msg": "退出成功", "data": null}`

**与前端交互**：
- 前端调用后，清除本地缓存（如有）
- 前端跳转到登录页面
- 浏览器自动清除JSESSIONID cookie（会话销毁后）

**边界处理**：
- 未登录用户调用：不会报错，直接返回成功（幂等操作）
- 会话已过期：同样返回成功

**Python端交互**：无，纯Java后端处理。

## 3. 模块间依赖与扩展性

### 依赖

**核心依赖**：
- Spring Web：提供RESTful API和Session支持
- Spring Data JPA：提供数据持久化
- MySQL Connector：数据库驱动
- Jakarta Validation：请求参数验证
- Lombok：简化代码（可选，当前未使用）

**无外部服务依赖**：所有功能均在Java后端完成，无需调用外部API或服务。

### 与其它模块集成

**用户管理模块**：
- 当前用户实体（AuthUser）可扩展为完整用户表（如用户名、邮箱、角色等）
- 登录时从用户表获取用户信息，支持角色权限控制

**权限管理模块**：
- 当前通过`admin-only-id`硬编码管理员，后续可扩展为角色表（Role）和权限表（Permission）
- 登录成功后，在会话中存储用户角色，其他模块通过拦截器检查角色

**日志审计模块**：
- 登录成功记录IP和时间（已实现）
- 可扩展为登录日志表（LoginLog），记录所有登录尝试（成功/失败）

**安全模块**：
- 密码加密：当前明文存储，需升级为BCrypt加密
- 登录失败次数限制：可添加失败计数器，超过阈值锁定账号
- 异地登录检测：对比IP地址，异常登录发送告警

### 扩展点

**验证码增强**：
- 图形验证码升级为滑块验证码或点选验证码（接入第三方服务）
- 短信验证码：集成短信服务商API，支持手机号登录
- 邮箱验证码：集成邮件服务，支持邮箱登录

**登录方式扩展**：
- 支持多种登录方式：账号密码、手机号验证码、邮箱验证码、第三方登录（微信、QQ）
- 单点登录（SSO）：集成JWT token，支持跨域登录

**会话管理增强**：
- Redis Session Store：集群环境下共享会话
- 会话并发控制：限制同一用户只能有一个活跃会话（踢出旧会话）
- 会话监控：实时查看在线用户列表

**安全加固**：
- 密码策略：强制复杂密码、定期更换
- 双因素认证（2FA）：集成TOTP或短信验证
- 登录风控：检测异常登录行为（如频繁失败、异地登录）

### 潜在风险与缓解

**密码安全风险**：
- 当前明文存储，存在泄露风险
- 缓解：升级为BCrypt加密，密码加盐存储

**会话劫持风险**：
- HTTP传输可能被中间人攻击
- 缓解：启用HTTPS，使用Secure和HttpOnly cookie

**验证码绕过风险**：
- 验证码可能被OCR识别
- 缓解：增加干扰线、扭曲文字、滑块验证码

**并发登录风险**：
- 当前允许多个会话，可能存在账号共享
- 缓解：限制单点登录，新登录踢出旧会话

**数据库性能风险**：
- 高并发下数据库查询可能成为瓶颈
- 缓解：添加Redis缓存用户信息，TTL 30分钟

**验证码内存泄漏风险**：
- 过期验证码未及时清理可能占用内存
- 缓解：定期清理任务（当前validate时清理，可增加定时任务）




